<div id="pf16c" class="pf w0 h0" data-page-no="16c"><div class="pc pc16c w0 h0"><img class="bi x0 y8 w2 h5" alt="" src="bg16c.png"/><div class="t m0 x33 hf yf6 ff3 fs5 fc0 sc0 ls0 ws0">•<span class="_ _11"> </span>Dual-address write—The DMA controller drives the DAR<span class="ff4 ws1a6">n</span> value onto the system</div><div class="t m0 x117 hf yf7 ff3 fs5 fc0 sc0 ls0 ws0">address bus. When the appropriate number of write cycles complete (multiple writes</div><div class="t m0 x117 hf yf8 ff3 fs5 fc0 sc0 ls0 ws0">if the source size is larger than the destination), DAR<span class="ff4 ws1a6">n</span> increments by the appropriate</div><div class="t m0 x117 hf yf9 ff3 fs5 fc0 sc0 ls0 ws0">number of bytes if DCRn[DINC] is set. BCRn decrements by the appropriate number</div><div class="t m0 x117 hf yfa ff3 fs5 fc0 sc0 ls0 ws0">of bytes. DSR<span class="ff4 ws1a6">n</span>[DONE] is set when BCR<span class="ff4 ws1a6">n</span> reaches zero. If the BCR<span class="ff4 ws1a6">n</span> is greater than</div><div class="t m0 x117 hf yfb ff3 fs5 fc0 sc0 ls0 ws0">zero, another read/write transfer is initiated if continuous mode is enabled</div><div class="t m0 x117 hf yfc ff3 fs5 fc0 sc0 ls0 ws0">(DCRn[CS] = 0).</div><div class="t m0 x117 hf y644 ff3 fs5 fc0 sc0 ls0 ws0">If a termination error occurs, DSR<span class="ff4 ws1a6">n</span>[BED, DONE] are set and DMA transactions</div><div class="t m0 x117 hf y645 ff3 fs5 fc0 sc0 ls0">stop.</div><div class="t m0 x9 he y2053 ff1 fs1 fc0 sc0 ls0 ws0">23.4.4<span class="_ _b"> </span>Advanced Data Transfer Controls: Auto-Alignment</div><div class="t m0 x9 hf y2054 ff3 fs5 fc0 sc0 ls0 ws0">Typically, auto-alignment for DMA transfers applies for transfers of large blocks of data.</div><div class="t m0 x9 hf y1e05 ff3 fs5 fc0 sc0 ls0 ws0">As a result, it does not apply for peripheral-initiated cycle-steal transfers.</div><div class="t m0 x9 hf ya38 ff3 fs5 fc0 sc0 ls0 ws0">Auto-alignment allows block transfers to occur at the optimal size based on the address,</div><div class="t m0 x9 hf y1a97 ff3 fs5 fc0 sc0 ls0 ws0">byte count, and programmed size. To use this feature, DCR<span class="ff4 ws1a6">n</span>[AA] must be set. The</div><div class="t m0 x9 hf y1a98 ff3 fs5 fc0 sc0 ls0 ws0">source is auto-aligned if DCR<span class="ff4 ws1a6">n</span>[SSIZE] indicates a transfer size larger than</div><div class="t m0 x9 hf y1a99 ff3 fs5 fc0 sc0 ls0 ws1a6">DCR<span class="ff4">n</span><span class="ws0">[DSIZE]. Source alignment takes precedence over the destination when the source</span></div><div class="t m0 x9 hf y1a9a ff3 fs5 fc0 sc0 ls0 ws0">and destination sizes are equal. Otherwise, the destination is auto-aligned. The address</div><div class="t m0 x9 hf y2055 ff3 fs5 fc0 sc0 ls0 ws0">register chosen for alignment increments regardless of the increment value. Configuration</div><div class="t m0 x9 hf y2056 ff3 fs5 fc0 sc0 ls0 ws0">error checking is performed on registers not chosen for alignment.</div><div class="t m0 x9 hf y2057 ff3 fs5 fc0 sc0 ls0 ws0">If BCR<span class="ff4 ws1a6">n</span> is greater than 16, the address determines transfer size. Transfers of 8 bits, 16</div><div class="t m0 x9 hf y2058 ff3 fs5 fc0 sc0 ls0 ws0">bits, or 32 bits are transferred until the address is aligned to the programmed size</div><div class="t m0 x9 hf y2059 ff3 fs5 fc0 sc0 ls0 ws0">boundary, at which time accesses begin using the programmed size. If BCR<span class="ff4 ws1a6">n</span> is less than</div><div class="t m0 x9 hf y205a ff3 fs5 fc0 sc0 ls0 ws0">16 at the start of a transfer, the number of bytes remaining dictates transfer size.</div><div class="t m0 x9 hf y205b ff3 fs5 fc0 sc0 ls0 ws0">Consider this example:</div><div class="t m0 x33 hf y205c ff3 fs5 fc0 sc0 ls0 ws0">•<span class="_ _11"> </span>AA equals 1.</div><div class="t m0 x33 hf y205d ff3 fs5 fc0 sc0 ls0 ws197">• SAR<span class="ff4 ws1a6">n</span><span class="ws0"> equals 0x2000_0001.</span></div><div class="t m0 x33 hf y205e ff3 fs5 fc0 sc0 ls0 ws197">• BCR<span class="ff4 ws1a6">n</span><span class="ws0"> equals 0x00_00F0.</span></div><div class="t m0 x33 hf y205f ff3 fs5 fc0 sc0 ls0 ws0">•<span class="_ _11"> </span>SSIZE equals 00 (32 bits).</div><div class="t m0 x33 hf y2060 ff3 fs5 fc0 sc0 ls0 ws0">•<span class="_ _11"> </span>DSIZE equals 01 (8 bits).</div><div class="t m0 x9 hf y2061 ff3 fs5 fc0 sc0 ls0 ws0">Because SSIZE &gt; DSIZE, the source is auto-aligned. Error checking is performed on</div><div class="t m0 x9 hf y2062 ff3 fs5 fc0 sc0 ls0 ws0">destination registers. The access sequence is as follows:</div><div class="t m0 xf6 hf y2063 ff3 fs5 fc0 sc0 ls0 ws0">1.<span class="_ _11"> </span>Read 1 byte from 0x2000_0001, increment SAR<span class="ff4 ws1a6">n</span>, write 1 byte (using DAR<span class="ff4 ws1a6">n</span>).</div><div class="t m0 xf6 hf y2064 ff3 fs5 fc0 sc0 ls0 ws0">2.<span class="_ _11"> </span>Read 2 bytes from 0x2000_0002, increment SAR<span class="ff4 ws1a6">n</span>, write 2 bytes.</div><div class="t m0 x9 h10 ydd ff1 fs4 fc0 sc0 ls0 ws0">Functional Description</div><div class="t m0 x8 h6 y9 ff1 fs3 fc0 sc0 ls0 ws0">KL25 Sub-Family Reference Manual, Rev. 3, September 2012</div><div class="t m0 x9 h7 ya ff2 fs4 fc0 sc0 ls0 ws0">364<span class="_ _113"> </span>Freescale Semiconductor, Inc.</div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
