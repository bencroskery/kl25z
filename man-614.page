<div id="pf266" class="pf w0 h0" data-page-no="266"><div class="pc pc266 w0 h0"><img class="bi x0 y8 w2 h5" alt="" src="bg266.png"/><div class="t m0 x9 he y17c ff1 fs1 fc0 sc0 ls0 ws0">35.2.1<span class="_ _b"> </span>Data Structures</div><div class="t m0 x9 hf y17d ff3 fs5 fc0 sc0 ls0 ws0">The function of the device operation is to transfer a request in the memory image to and</div><div class="t m0 x9 hf y80d ff3 fs5 fc0 sc0 ls0 ws0">from the Universal Serial Bus. To efficiently manage USB endpoint communications the</div><div class="t m0 x9 hf y80e ff3 fs5 fc0 sc0 ls0 ws0">USB-FS implements a Buffer Descriptor Table (BDT) in system memory. See <span class="fc1">Figure</span></div><div class="t m0 x9 hf y80f ff3 fs5 fc1 sc0 ls0 ws1a6">35-3<span class="fc0">.</span></div><div class="t m0 x9 hd y35ed ff1 fs7 fc0 sc0 ls0 ws0">35.3<span class="_ _b"> </span>Programmers interface</div><div class="t m0 x9 hf y2b56 ff3 fs5 fc0 sc0 ls0 ws0">This section discusses the major components of the programming model for the USB</div><div class="t m0 x9 hf y35ee ff3 fs5 fc0 sc0 ls0">module.</div><div class="t m0 x9 he y35ef ff1 fs1 fc0 sc0 ls0 ws0">35.3.1<span class="_ _b"> </span>Buffer Descriptor Table</div><div class="t m0 x9 hf y35f0 ff3 fs5 fc0 sc0 ls0 ws0">To efficiently manage USB endpoint communications the USB-FS implements a Buffer</div><div class="t m0 x9 hf y308d ff3 fs5 fc0 sc0 ls0 ws0">Descriptor Table (BDT) in system memory. The BDT resides on a 512-byte boundary in</div><div class="t m0 x9 hf y35f1 ff3 fs5 fc0 sc0 ls0 ws0">system memory and is pointed to by the BDT Page Registers. Every endpoint direction</div><div class="t m0 x9 hf y35f2 ff3 fs5 fc0 sc0 ls0 ws0">requires two 8-byte Buffer Descriptor (BD) entries. Therefore, a system with 16 fully</div><div class="t m0 x9 hf y35f3 ff3 fs5 fc0 sc0 ls0 ws0">bidirectional endpoints would require 512 bytes of system memory to implement the</div><div class="t m0 x9 hf y35f4 ff3 fs5 fc0 sc0 ls0 ws0">BDT. The two BD entries allows for an EVEN BD and ODD BD entry for each endpoint</div><div class="t m0 x9 hf y35f5 ff3 fs5 fc0 sc0 ls0 ws0">direction. This allows the microprocessor to process one BD while the USB-FS is</div><div class="t m0 x9 hf y35f6 ff3 fs5 fc0 sc0 ls0 ws0">processing the other BD. Double buffering BDs in this way allows the USB-FS to</div><div class="t m0 x9 hf y35f7 ff3 fs5 fc0 sc0 ls0 ws0">transfer data easily at the maximum throughput provided by USB.</div><div class="t m0 x9 hf y35f8 ff3 fs5 fc0 sc0 ls0 ws0">The software API intelligently manages buffers for the USB-FS by updating the BDT</div><div class="t m0 x9 hf y35f9 ff3 fs5 fc0 sc0 ls0 ws0">when needed. This allows the USB-FS to efficiently manage data transmission and</div><div class="t m0 x9 hf y35fa ff3 fs5 fc0 sc0 ls0 ws0">reception, while the microprocessor performs communication overhead processing and</div><div class="t m0 x9 hf y35fb ff3 fs5 fc0 sc0 ls0 ws0">other function dependent applications. Because the buffers are shared between the</div><div class="t m0 x9 hf y35fc ff3 fs5 fc0 sc0 ls0 ws0">microprocessor and the USB-FS, a simple semaphore mechanism is used to distinguish</div><div class="t m0 x9 hf y35fd ff3 fs5 fc0 sc0 ls0 ws0">who is allowed to update the BDT and buffers in system memory. A semaphore, the</div><div class="t m0 x9 hf y35fe ff3 fs5 fc0 sc0 ls0 ws0">OWN bit, is cleared to 0 when the BD entry is owned by the microprocessor. The</div><div class="t m0 x9 hf y35ff ff3 fs5 fc0 sc0 ls0 ws0">microprocessor is allowed read and write access to the BD entry and the buffer in system</div><div class="t m0 x9 hf y3600 ff3 fs5 fc0 sc0 ls0 ws0">memory when the OWN bit is 0. When the OWN bit is set to 1, the BD entry and the</div><div class="t m0 x9 hf y3601 ff3 fs5 fc0 sc0 ls0 ws0">buffer in system memory are owned by the USB-FS. The USB-FS now has full read and</div><div class="t m0 x9 hf y3602 ff3 fs5 fc0 sc0 ls0 ws0">write access and the microprocessor must not modify the BD or its corresponding data</div><div class="t m0 x9 hf y3603 ff3 fs5 fc0 sc0 ls0 ws0">buffer. The BD also contains indirect address pointers to where the actual buffer resides</div><div class="t m0 x9 hf y3604 ff3 fs5 fc0 sc0 ls0 ws0">in system memory. This indirect address mechanism is shown in the following diagram.</div><div class="t m0 x9 h10 ydd ff1 fs4 fc0 sc0 ls0 ws0">Programmers interface</div><div class="t m0 x8 h6 y9 ff1 fs3 fc0 sc0 ls0 ws0">KL25 Sub-Family Reference Manual, Rev. 3, September 2012</div><div class="t m0 x9 h7 ya ff2 fs4 fc0 sc0 ls0 ws0">614<span class="_ _113"> </span>Freescale Semiconductor, Inc.</div><a class="l" href="#pf267" data-dest-detail='[615,"XYZ",null,723.6,null]'><div class="d m1" style="border-style:none;position:absolute;left:496.512000px;bottom:651.200000px;width:36.554000px;height:14.000000px;background-color:rgba(255,255,255,0.000001);"></div></a><a class="l" href="#pf267" data-dest-detail='[615,"XYZ",null,723.6,null]'><div class="d m1" style="border-style:none;position:absolute;left:54.000000px;bottom:635.200000px;width:25.662000px;height:14.000000px;background-color:rgba(255,255,255,0.000001);"></div></a></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
