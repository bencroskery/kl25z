<div id="pf26c" class="pf w0 h0" data-page-no="26c"><div class="pc pc26c w0 h0"><img class="bi x0 y8 w3 h5" alt="" src="bg26c.png"/><div class="c x39 y3685 w68 h193"><div class="t m0 x4f h7 y3686 ff2 fs4 fc0 sc0 ls0 ws0">SETUP TOKEN<span class="_ _7f"> </span>DA<span class="_ _153"></span>T<span class="_ _153"></span>A<span class="_ _85"> </span>ACK</div><div class="t m0 x39 h7 y3687 ff2 fs4 fc0 sc0 ls0 ws0">USB RST<span class="_ _d2"> </span>SOF</div><div class="t m0 x94 h194 y3688 ff2 fs4 fc0 sc0 ls0 ws0">IN TOKEN<span class="_ _32"> </span><span class="ws438 v0">DA<span class="_ _153"></span>T<span class="_ _154"></span>A ACK</span></div><div class="t m0 x3a h7 y3689 ff2 fs4 fc0 sc0 ls0 ws0">OUT TOKEN<span class="_ _15"> </span>D<span class="_ _5"></span>A<span class="_ _154"></span>T<span class="_ _153"></span>A<span class="_ _23a"> </span>ACK</div><div class="t m0 x9d h27 y368a ff2 fs4 fc0 sc0 ls0 ws190">USB_RST<span class="ff3 fs2 ws0"> </span></div><div class="t m0 x0 h7 y368b ff2 fs4 fc0 sc0 ls0 ws0">Interrupt Generated</div><div class="t m0 x33 h7 y368c ff2 fs4 fc0 sc0 ls0 ws0">USB Host<span class="_ _4f"> </span>Function</div><div class="t m0 x101 h27 y368d ff2 fs4 fc0 sc0 ls0 ws190">TOK_DNE<span class="_ _b5"></span><span class="ff3 fs2 ws0"> </span></div><div class="t m0 xb7 h7 y368e ff2 fs4 fc0 sc0 ls0 ws0">Interrupt Generated</div><div class="t m0 x12 h7 y368a ff2 fs4 fc0 sc0 ls0 ws0">SOF Interrupt Generated</div><div class="t m0 x101 h27 y368f ff2 fs4 fc0 sc0 ls0 ws190">TOK_DNE<span class="_ _b5"></span><span class="ff3 fs2 ws0"> </span></div><div class="t m0 xb7 h7 y3690 ff2 fs4 fc0 sc0 ls0 ws0">Interrupt Generated</div><div class="t m0 x101 h27 y3691 ff2 fs4 fc0 sc0 ls0 ws190">TOK_DNE<span class="_ _b5"></span><span class="ff3 fs2 ws0"> </span></div><div class="t m0 xb7 h7 y3692 ff2 fs4 fc0 sc0 ls0 ws0">Interrupt Generated</div></div><div class="t m0 x30 h9 y3693 ff1 fs2 fc0 sc0 ls0 ws0">Figure 35-4. USB token transaction</div><div class="t m0 x9 hf y3694 ff3 fs5 fc0 sc0 ls0 ws0">The USB has two sources for the DMA overrun error:</div><div class="t m0 x9 hf y3695 ff3 fs5 fc0 sc0 ls0 ws0">Memory Latency</div><div class="t m0 x9 hf y3696 ff3 fs5 fc0 sc0 ls0 ws0">The memory latency may be too high and cause the receive FIFO to overflow. This is</div><div class="t m0 x9 hf y3697 ff3 fs5 fc0 sc0 ls0 ws0">predominantly a hardware performance issue, usually caused by transient memory access</div><div class="t m0 x9 hf y3698 ff3 fs5 fc0 sc0 ls0">issues.</div><div class="t m0 x9 hf y3699 ff3 fs5 fc0 sc0 ls0 ws0">Oversized Packets</div><div class="t m0 x9 hf y369a ff3 fs5 fc0 sc0 ls0 ws0">The packet received may be larger than the negotiated <span class="ff4 ws1a6">MaxPacket</span> size. Typically, this is</div><div class="t m0 x9 hf y369b ff3 fs5 fc0 sc0 ls0 ws0">caused by a software bug. For DMA overrun errors due to oversized data packets, the</div><div class="t m0 x9 hf y369c ff3 fs5 fc0 sc0 ls0 ws0">USB specification is ambiguous. It assumes correct software drivers on both sides.</div><div class="t m0 x9 hf y369d ff3 fs5 fc0 sc0 ls0 ws0">NAKing the packet can result in retransmission of the already oversized packet data.</div><div class="t m0 x9 hf y369e ff3 fs5 fc0 sc0 ls0 ws0">Therefore, in response to oversized packets, the USB core continues ACKing the packet</div><div class="t m0 x9 hf y369f ff3 fs5 fc0 sc0 ls0 ws0">for non-isochronous transfers.</div><div class="t m0 x8 h9 y36a0 ff1 fs2 fc0 sc0 ls0 ws0">Table 35-5.<span class="_ _1a"> </span>USB responses to DMA overrun errors</div><div class="t m0 x7e h10 y36a1 ff1 fs4 fc0 sc0 ls0 ws0">Errors due to Memory Latency<span class="_ _75"> </span>Errors due to Oversized Packets</div><div class="t m0 x2c h7 y36a2 ff2 fs4 fc0 sc0 ls0 ws0">Non-Acknowledgment (NAK) or Bus Timeout (BTO) — See</div><div class="t m0 x2c h7 y36a3 ff2 fs4 fc0 sc0 ls0 ws0">bit 4 in &quot;Error Interrupt Status Register (ERRSTAT)&quot; as</div><div class="t m0 x2c h7 y36a4 ff2 fs4 fc0 sc0 ls0 ws0">appropriate for the class of transaction.</div><div class="t m0 x2d h7 y36a2 ff2 fs4 fc0 sc0 ls0 ws0">Continues acknowledging (ACKing) the packet for non-</div><div class="t m0 x2d h7 y36a3 ff2 fs4 fc0 sc0 ls0 ws0">isochronous transfers.</div><div class="t m0 x3 h86 y36a5 ff2 fs4 fc0 sc0 ls278">—<span class="ls0 ws0 v14">The data written to memory is clipped to the MaxPacket size</span></div><div class="t m0 x2d h7 y36a6 ff2 fs4 fc0 sc0 ls0 ws0">so as not to corrupt system memory.</div><div class="t m0 x2c h7 y36a7 ff2 fs4 fc0 sc0 ls0 ws0">The DMAERR bit is set in the ERRSTAT register for host and</div><div class="t m0 x2c h7 y36a8 ff2 fs4 fc0 sc0 ls0 ws0">device modes of operation. Depending on the values of the</div><div class="t m0 x2c h7 y36a9 ff2 fs4 fc0 sc0 ls0 ws0">INTENB and ERRENB register, the core may assert an</div><div class="t m0 x2c h7 y36aa ff2 fs4 fc0 sc0 ls0 ws0">interrupt to notify the processor of the DMA error.</div><div class="t m0 x2d h7 y36a7 ff2 fs4 fc0 sc0 ls0 ws0">Asserts ERRSTAT[DMAERR] ,which can trigger an interrupt</div><div class="t m0 x2d h7 y36a8 ff2 fs4 fc0 sc0 ls0 ws0">and TOKDNE interrupt fires. Note: The TOK_PID field of the</div><div class="t m0 x2d h7 y36a9 ff2 fs4 fc0 sc0 ls0 ws0">BDT is not 1111 because the DMAERR is not due to latency.</div><div class="t m0 x1b h7 y36ab ff5 fs4 fc0 sc0 ls0 ws0">Table continues on the next page...</div><div class="t m0 x9 h10 ydd ff1 fs4 fc0 sc0 ls0 ws0">Programmers interface</div><div class="t m0 x8 h6 y9 ff1 fs3 fc0 sc0 ls0 ws0">KL25 Sub-Family Reference Manual, Rev. 3, September 2012</div><div class="t m0 x9 h7 ya ff2 fs4 fc0 sc0 ls0 ws0">620<span class="_ _113"> </span>Freescale Semiconductor, Inc.</div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
