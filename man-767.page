<div id="pf2ff" class="pf w0 h0" data-page-no="2ff"><div class="pc pc2ff w0 h0"><img class="bi x0 y8 w2 h5" alt="" src="bg2ff.png"/><div class="t m0 x9 hf yf6 ff3 fs5 fc0 sc0 ls0 ws0">Address-mark wakeup allows messages to contain idle characters, but requires the msb</div><div class="t m0 x9 hf yf7 ff3 fs5 fc0 sc0 ls0 ws0">be reserved for use in address frames. The one, or two, if UART_BDH[SBNS] = 1, logic</div><div class="t m0 x9 hf yf8 ff3 fs5 fc0 sc0 ls0 ws0">1s msb of an address frame clears the UART_C2[RWU] bit before the stop bits are</div><div class="t m0 x9 hf yf9 ff3 fs5 fc0 sc0 ls0 ws0">received and sets the UART_S1[RDRF] flag. In this case, the character with the msb set</div><div class="t m0 x9 hf yfa ff3 fs5 fc0 sc0 ls0 ws0">is received even though the receiver was sleeping during most of this character time.</div><div class="t m0 x9 he y28f3 ff1 fs1 fc0 sc0 ls0 ws0">40.3.4<span class="_ _b"> </span>Interrupts and status flags</div><div class="t m0 x9 hf y28f4 ff3 fs5 fc0 sc0 ls0 ws0">The UART system has three separate interrupt vectors to reduce the amount of software</div><div class="t m0 x9 hf y28f5 ff3 fs5 fc0 sc0 ls0 ws0">needed to isolate the cause of the interrupt. One interrupt vector is associated with the</div><div class="t m0 x9 hf y28f6 ff3 fs5 fc0 sc0 ls0 ws0">transmitter for UART_S1[TDRE] and UART_S1[TC] events. Another interrupt vector is</div><div class="t m0 x9 hf y2701 ff3 fs5 fc0 sc0 ls0 ws0">associated with the receiver for RDRF, IDLE, RXEDGIF, and LBKDIF events. A third</div><div class="t m0 x9 hf y2702 ff3 fs5 fc0 sc0 ls0 ws0">vector is used for OR, NF, FE, and PF error conditions. Each of these ten interrupt</div><div class="t m0 x9 hf y2703 ff3 fs5 fc0 sc0 ls0 ws0">sources can be separately masked by local interrupt enable masks. The flags can be</div><div class="t m0 x9 hf y2704 ff3 fs5 fc0 sc0 ls0 ws0">polled by software when the local masks are cleared to disable generation of hardware</div><div class="t m0 x9 hf y2c06 ff3 fs5 fc0 sc0 ls0 ws0">interrupt requests.</div><div class="t m0 x9 hf y2706 ff3 fs5 fc0 sc0 ls0 ws0">The UART transmitter has two status flags that can optionally generate hardware</div><div class="t m0 x9 hf y2707 ff3 fs5 fc0 sc0 ls0 ws0">interrupt requests. Transmit data register empty (UART_S1[TDRE]) indicates when there</div><div class="t m0 x9 hf y2708 ff3 fs5 fc0 sc0 ls0 ws0">is room in the transmit data buffer to write another transmit character to UART_D. If the</div><div class="t m0 x9 hf ya4f ff3 fs5 fc0 sc0 ls0 ws0">transmit interrupt enable (UART_C2[TIE]) bit is set, a hardware interrupt is requested</div><div class="t m0 x9 hf y41e5 ff3 fs5 fc0 sc0 ls0 ws0">when UART_S1[TDRE] is set. Transmit complete (UART_S1[TC]) indicates that the</div><div class="t m0 x9 hf y41e6 ff3 fs5 fc0 sc0 ls0 ws0">transmitter is finished transmitting all data, preamble, and break characters and is idle</div><div class="t m0 x9 hf y41e7 ff3 fs5 fc0 sc0 ls0 ws0">with TxD at the inactive level. This flag is often used in systems with modems to</div><div class="t m0 x9 hf y41e8 ff3 fs5 fc0 sc0 ls0 ws0">determine when it is safe to turn off the modem. If the transmit complete interrupt enable</div><div class="t m0 x9 hf y41e9 ff3 fs5 fc0 sc0 ls0 ws0">(UART_C2[TCIE]) bit is set, a hardware interrupt is requested when UART_S1[TC] is</div><div class="t m0 x9 hf y41ea ff3 fs5 fc0 sc0 ls0 ws0">set. Instead of hardware interrupts, software polling may be used to monitor the</div><div class="t m0 x9 hf y41eb ff3 fs5 fc0 sc0 ls0 ws0">UART_S1[TDRE] and UART_S1[TC] status flags if the corresponding UART_C2[TIE]</div><div class="t m0 x9 hf y235a ff3 fs5 fc0 sc0 ls0 ws0">or UART_C2[TCIE] local interrupt masks are cleared.</div><div class="t m0 x9 hf y235b ff3 fs5 fc0 sc0 ls0 ws0">When a program detects that the receive data register is full (UART_S1[RDRF] = 1), it</div><div class="t m0 x9 hf y41ed ff3 fs5 fc0 sc0 ls0 ws0">gets the data from the receive data register by reading UART_D. The UART_S1[RDRF]</div><div class="t m0 x9 hf y41ee ff3 fs5 fc0 sc0 ls0 ws0">flag is cleared by reading UARTxS1 while UART_S1[RDRF] is set and then reading</div><div class="t m0 x9 hf y41ef ff3 fs5 fc0 sc0 ls0">UART_D.</div><div class="t m0 x9 hf y41f0 ff3 fs5 fc0 sc0 ls0 ws0">When polling is used, this sequence is naturally satisfied in the normal course of the user</div><div class="t m0 x9 hf y41f1 ff3 fs5 fc0 sc0 ls0 ws0">program. If hardware interrupts are used, UARTxS1 must be read in the interrupt service</div><div class="t m0 x9 hf y41f2 ff3 fs5 fc0 sc0 ls0 ws0">routine (ISR). Normally, this is done in the ISR anyway to check for receive errors, so the</div><div class="t m0 x9 hf y41f3 ff3 fs5 fc0 sc0 ls0 ws0">sequence is automatically satisfied.</div><div class="t m0 x21 h10 y141 ff1 fs4 fc0 sc0 ls0 ws0">Chapter 40 Universal Asynchronous Receiver/Transmitter (UART1 and UART2)</div><div class="t m0 x8 h6 y9 ff1 fs3 fc0 sc0 ls0 ws0">KL25 Sub-Family Reference Manual, Rev. 3, September 2012</div><div class="t m0 x9 h7 ya ff2 fs4 fc0 sc0 ls0 ws0">Freescale Semiconductor, Inc.<span class="_ _113"> </span>767</div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
