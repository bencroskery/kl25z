<div id="pf300" class="pf w0 h0" data-page-no="300"><div class="pc pc300 w0 h0"><img class="bi x0 y8 w3 h5" alt="" src="bg300.png"/><div class="t m0 x9 hf yf6 ff3 fs5 fc0 sc0 ls0 ws0">The IDLE status flag includes logic that prevents it from getting set repeatedly when the</div><div class="t m0 x9 hf yf7 ff3 fs5 fc0 sc0 ls0 ws0">RxD line remains idle for an extended period of time. IDLE is cleared by reading</div><div class="t m0 x9 hf yf8 ff3 fs5 fc0 sc0 ls0 ws0">UARTxS1 while UART_S1[IDLE] is set and then reading UART_D. After</div><div class="t m0 x9 hf yf9 ff3 fs5 fc0 sc0 ls0 ws0">UART_S1[IDLE] has been cleared, it cannot become set again until the receiver has</div><div class="t m0 x9 hf yfa ff3 fs5 fc0 sc0 ls0 ws0">received at least one new character and has set UART_S1[RDRF].</div><div class="t m0 x9 hf y62a ff3 fs5 fc0 sc0 ls0 ws0">If the associated error was detected in the received character that caused</div><div class="t m0 x9 hf yabd ff3 fs5 fc0 sc0 ls0 ws0">UART_S1[RDRF] to be set, the error flags - noise flag (UART_S1[NF]), framing error</div><div class="t m0 x9 hf y644 ff3 fs5 fc0 sc0 ls0 ws0">(UART_S1[FE]), and parity error flag (UART_S1[PF]) - are set at the same time as</div><div class="t m0 x9 hf y645 ff3 fs5 fc0 sc0 ls0 ws0">UART_S1[RDRF]. These flags are not set in overrun cases.</div><div class="t m0 x9 hf yad6 ff3 fs5 fc0 sc0 ls0 ws0">If UART_S1[RDRF] was already set when a new character is ready to be transferred</div><div class="t m0 x9 hf yad7 ff3 fs5 fc0 sc0 ls0 ws0">from the receive shifter to the receive data buffer, the overrun (UART_S1[OR]) flag is</div><div class="t m0 x9 hf y2040 ff3 fs5 fc0 sc0 ls0 ws0">set instead of the data along with any associated NF, FE, or PF condition is lost.</div><div class="t m0 x9 hf yad9 ff3 fs5 fc0 sc0 ls0 ws0">At any time, an active edge on the RxD serial data input pin causes the</div><div class="t m0 x9 hf yada ff3 fs5 fc0 sc0 ls0 ws0">UART_S2[RXEDGIF] flag to set. The UART_S2[RXEDGIF] flag is cleared by writing a</div><div class="t m0 x9 hf yadb ff3 fs5 fc0 sc0 ls0 ws0">1 to it. This function depends on the receiver being enabled (UART_C2[RE] = 1).</div><div class="t m0 x9 he y43cd ff1 fs1 fc0 sc0 ls0 ws0">40.3.5<span class="_ _b"> </span>DMA Operation</div><div class="t m0 x9 hf y43ce ff3 fs5 fc0 sc0 ls0 ws0">In the transmitter, flags TDRE and TC can be configured to assert a DMA transfer</div><div class="t m0 x9 hf yade ff3 fs5 fc0 sc0 ls0 ws0">request. In the receiver, flags RDRF, IDLE and LBKDIF can be configured to assert a</div><div class="t m0 x9 hf yadf ff3 fs5 fc0 sc0 ls0 ws0">DMA transfer request. The following table shows the configuration bit settings required</div><div class="t m0 x9 hf yae0 ff3 fs5 fc0 sc0 ls0 ws0">to configure each flag for DMA operation.</div><div class="t m0 x20 h9 y43cf ff1 fs2 fc0 sc0 ls0 ws0">Table 40-32.<span class="_ _1a"> </span>DMA configuration</div><div class="t m0 xf0 h10 y43d0 ff1 fs4 fc0 sc0 ls0 ws0">Flag<span class="_ _257"> </span>Request enable bit<span class="_ _13e"> </span>DMA select bit</div><div class="t m0 x3e h7 y43d1 ff2 fs4 fc0 sc0 ls0 ws0">TDRE<span class="_ _c4"> </span>TIE = 1<span class="_ _e9"> </span>TDMAS = 1</div><div class="t m0 x83 h7 y43d2 ff2 fs4 fc0 sc0 ls0 ws0">TC<span class="_ _258"> </span>TCIE = 1<span class="_ _259"> </span>TCDMAS = 1</div><div class="t m0 x3e h7 y43d3 ff2 fs4 fc0 sc0 ls0 ws0">RDRF<span class="_ _235"> </span>RIE = 1<span class="_ _1a0"> </span>RDMAS = 1</div><div class="t m0 xad h7 y43d4 ff2 fs4 fc0 sc0 ls0 ws0">IDLE<span class="_ _d7"> </span>ILIE = 1<span class="_ _25a"> </span>ILDMAS = 1</div><div class="t m0 xac h7 y43d5 ff2 fs4 fc0 sc0 ls0 ws0">LBKDIF<span class="_ _1a0"> </span>LBKDIE = 1<span class="_ _a7"> </span>LBKDDMAS = 1</div><div class="t m0 x9 hf y43d6 ff3 fs5 fc0 sc0 ls0 ws0">When a flag is configured for a DMA request, its associated DMA request is asserted</div><div class="t m0 x9 hf y43d7 ff3 fs5 fc0 sc0 ls0 ws0">when the flag is set. When the RDRF or IDLE flag is configured as a DMA request, the</div><div class="t m0 x9 hf y43d8 ff3 fs5 fc0 sc0 ls0 ws0">clearing mechanism of reading UART_S1 followed by reading UART_D does not clear</div><div class="t m0 x9 hf y43d9 ff3 fs5 fc0 sc0 ls0 ws0">the associated flag.The DMA request remains asserted until an indication is received that</div><div class="t m0 x9 hf y43da ff3 fs5 fc0 sc0 ls0 ws0">the DMA transactions are done. When this indication is received, the flag bit and the</div><div class="t m0 x9 hf y43db ff3 fs5 fc0 sc0 ls0 ws0">associated DMA request are cleared. If the DMA operation failed to remove the situation</div><div class="t m0 x9 hf y43dc ff3 fs5 fc0 sc0 ls0 ws0">that caused the DMA request another request will be issued.</div><div class="t m0 x9 h10 ydd ff1 fs4 fc0 sc0 ls0 ws0">Functional description</div><div class="t m0 x8 h6 y9 ff1 fs3 fc0 sc0 ls0 ws0">KL25 Sub-Family Reference Manual, Rev. 3, September 2012</div><div class="t m0 x9 h7 ya ff2 fs4 fc0 sc0 ls0 ws0">768<span class="_ _113"> </span>Freescale Semiconductor, Inc.</div></div><div class="pi" data-data='{"ctm":[1.000000,0.000000,0.000000,1.000000,0.000000,0.000000]}'></div></div>
